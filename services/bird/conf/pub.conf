# Public network filters

roa4 table pub_roa4;
roa6 table pub_roa6;

function check_pub_roa() {
	case net.type {
		NET_IP4: return roa_check(pub_roa4, net, bgp_path.last);
		NET_IP6: return roa_check(pub_roa6, net, bgp_path.last);
		else: print "check_pub_roa: unexpected net.type ", net.type, " ", net; return ROA_INVALID;
	}
}

protocol rpki pub_rpki_cf {
	roa4 { table pub_roa4; };
	roa6 { table pub_roa6; };

	remote "rtr.rpki.cloudflare.com" port 8282;

	retry keep 90;
	refresh keep 1800;
	expire keep 172800;
}

% pubExportPrefixesV6=('2602:2c3:810::/44' '2a0e:b107:16c0::/48' '2a0e:b107:16c0::/44')

define PUB_EXPORT_PREFIXES_V6 = [ <%% IFS=','; echo "${pubExportPrefixesV6[*]}" %> ];

protocol static pub_static6 {
	% for prefix in "${pubExportPrefixesV6[@]}"; do
	route <% $prefix %> reject;
	% done

	ipv6 { import all; export none; };
};

function is_pub_export_prefix() -> bool {
	case net.type {
		NET_IP4: return false;
		NET_IP6: return net ~ PUB_EXPORT_PREFIXES_V6;
		else: print "is_pub_export_prefix: unexpected net.type ", net.type, " ", net; return false;
	}
}

function is_pub_prefix() -> bool {
	case net.type {
		NET_IP4: return net ~ [ 0.0.0.0/0{8,24} ] && ! is_bogon_prefix();
		NET_IP6: return net ~ [ ::/0{8,64} ] && ! is_bogon_prefix();
		else: print "is_pub_prefix: unexpected net.type ", net.type, " ", net; return false;
	}
}

function pub_filter_import() -> bool {
	if ! is_pub_prefix() then return false;
	if is_xvnet_prefix() then return false;
	if COMMUNITY_XVN_NO_IMPORT ~ bgp_large_community then return false;
	if check_pub_roa() = ROA_INVALID then {
		# print "[pub] ROA failed for ", net, " ASN ", bgp_path.last, " proto ", proto;
		return false;
	}
	bgp_large_community.delete(COMMUNITY_XVN_SOURCE);
	bgp_large_community.delete(COMMUNITY_XVN_EXPORT_NODE);
	if COMMUNITY_XVN_UNSAFE_TRANSIT ~ bgp_large_community then bgp_local_pref = bgp_local_pref - 20;
	return true;
}

function pub_filter_export() -> bool {
	if ! is_pub_prefix() then return false;
	if is_xvnet_prefix() && ! is_pub_export_prefix() then return false;
	if COMMUNITY_XVN_NO_EXPORT ~ bgp_large_community then return false;

	strip_confed_as();
	bgp_large_community.add(COMMUNITY_XVN_EXPORT_SELF);
	return true;
}

# Peers
filter pub_import_peer {
	if ! pub_filter_import() then reject;
	if bgp_path.len > 16 then {
		# print "[pub] BGP path too long ", net, " len ", bgp_path.len, " proto ", proto, bgp_path;
		reject;
	}
	bgp_large_community.add(COMMUNITY_XVN_SOURCE_PEER);
	bgp_local_pref = bgp_local_pref + 50;
	accept;
}

filter pub_export_peer {
	if ! pub_filter_export() then reject;
	if COMMUNITY_XVN_SOURCE_UPSTREAM ~ bgp_large_community then reject;
	if ! ( is_pub_export_prefix() || COMMUNITY_XVN_SOURCE_PEER ~ bgp_large_community
		|| COMMUNITY_XVN_SOURCE_DOWNSTREAM ~ bgp_large_community) then reject;
	accept;
}

template bgp pub_peer {
	local as 199304;
	graceful restart on;

	ipv4 {
		import none;
		export none;
	};

	ipv6 {
		import filter pub_import_peer;
		export filter pub_export_peer;
		import limit 100 action block;
		export limit 100 action disable;
		
		rpki reload on;
		import table on;
		export table on;
	};
}

# Upstream
filter pub_import_upstream {
	if ! pub_filter_import() then reject;
	if bgp_path.len > 32 then {
		# print "[pub] BGP path too long ", net, " len ", bgp_path.len, " proto ", proto, bgp_path;
		reject;
	}
	bgp_large_community.add(COMMUNITY_XVN_SOURCE_UPSTREAM);
	accept;
}

filter pub_export_upstream {
	if COMMUNITY_XVN_SOURCE_UPSTREAM ~ bgp_large_community then reject;
	if ! ( is_pub_export_prefix() || COMMUNITY_XVN_SOURCE_PEER ~ bgp_large_community
		|| COMMUNITY_XVN_SOURCE_DOWNSTREAM ~ bgp_large_community) then reject;
	if ! pub_filter_export() then reject;
	accept;
}

template bgp pub_upstream {
	local as 199304;

	ipv4 {
		import none;
		export none;
	};

	ipv6 {
		import filter pub_import_upstream;
		export filter pub_export_upstream;
		export limit 100 action disable;
		
		# rpki reload on;
		# import table on;
		export table on;
	};
}

include "/etc/bird/pub.conf";
